using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Media;
using System.Security.Principal;
using RimWorld;
using RimWorld.Planet;
using RimWorld.QuestGen;
using Unity.IO.LowLevel.Unsafe;
using UnityEngine;
using Verse;
using Verse.AI;
using Verse.Noise;
using Verse.Sound;
using static HarmonyLib.Code;

namespace MapDrill
{
    [StaticConstructorOnStartup]
    public class CompDrill_MapDrill : ThingComp
    {
        /* todo: 
         * map wide range                       -done
         * consume steel when in use.           -done
         * gizmo selection                      -done
         * make random chance for slag to spawn during drill ticks (expose chance to xml). -tbd
         * make it work unmanned by at a slower rate
         * progress bar like a solar panel?
        */
        public static readonly Texture2D DebugShowVariablesIcon = ContentFinder<Texture2D>.Get("UI/Designators/Claim");
        public static readonly Texture2D GizmoShowMapIcon = ContentFinder<Texture2D>.Get("UI/Commands/ShowMap");
        public static readonly Texture2D ChunkSlagSteel = ContentFinder<Texture2D>.Get("Things/Item/Chunk/ChunkSlag/MetalDebrisA");



        public CompProperties_MapDrill Props => (CompProperties_MapDrill)props;
        public CompProperties_Refuelable_MapDrill Props2 => (CompProperties_Refuelable_MapDrill)props;

        private static ThingDef MapDrillDef = DefDatabase<ThingDef>.GetNamed("MapDrill");
        private static ThingDef chunkSlagSteelDef = DefDatabase<ThingDef>.GetNamed("ChunkSlagSteel");
        private static SoundDef chunkSlagSound = DefDatabase<SoundDef>.GetNamed("Standard_Drop");//Building_Deconstructed wasn't bad, neither was Crunch

        private IntVec3 lastCell = new IntVec3(0, 0, 0);
        //public static int targetResourceRemaining = 0; // no longer used - delete
        private ThingDef gizmoTargetResource; // list publically available in case of multiple map drills
        private ThingDef TargetDrillingDef; // local to eachdrill 
        private IntVec3 TargetDrillingCell; // local to eachdrill 
        private int TargetDrillingCountRemaining; // local to eachdrill
        private int distanceCellsDug = 0;
        private float distanceToCell; // distance between drill and targetCell
        private int distanceToDig => (int)distanceToCell - distanceCellsDug;   //  distance remaining to dig to get to actually drill for 
        private bool drillAutoMode = true; // false = manual , true = automatic
        private float steelConsumed;
        private bool isPawnWorking;
        public Pawn driller;
        public WorkGiverDef mapDrillWorkGiverDef = DefDatabase<WorkGiverDef>.GetNamed("MapDrill");
        private Effecter effecter;
        private int tickCount;


        private Dictionary<IntVec3, ThingDef> deepResourceDictionary = new Dictionary<IntVec3, ThingDef>();
        private Dictionary<int, string> drillStatusDictionary = new Dictionary<int, string>()
        {
            {1, "MapDrillStatusActiveManned" },
            {2, "MapDrillStatusActiveUnmanned" }, // to be implemented
            {3, "MapDrillStatusActiveStandby" },
            {4, "MapDrillStatusActiveOffline" },
            {5, "MapDrillStatusActiveDigging" },
        };

        private CompPowerTrader powerComp;
        private CompRefuelable_MapDrill refuelableComp;
        private CompFlickable flickComp;

        public CompProperties_Refuelable_MapDrill compRefuelableProps = MapDrillDef.GetCompProperties<CompProperties_Refuelable_MapDrill>(); //unused...

        private float portionProgress;
        private float portionYieldPct;

        private float digProgress = 0f;
        private int digOrDrill = 0;// 0 = dig mode, 1 = drill mode
        private int drillStatus; // 1 = Active (Drilling), 2 = tbd, 3 = Standy, 4 = Offline, 5 = Digging
        private float fuelRatePerTick;
        private float fuelRatePerHour;
        private float slagChunkEveryNumSteelConsumed;

        private Sustainer sustainer;
        //private SoundDef drillSound = DefDatabase<SoundDef>.GetNamed("Interact_Drill");

        private float ProgressToNextPortionPercent => portionProgress / 10000f;
        private float DigProgressToNextPortionPercent => digProgress / 10000f;

        public override void PostSpawnSetup(bool respawningAfterLoad)
        {
            powerComp = parent.TryGetComp<CompPowerTrader>();
            refuelableComp = parent.TryGetComp<CompRefuelable_MapDrill>();
            flickComp = parent.TryGetComp<CompFlickable>();
            /*distanceToDig = (int)Vector3.Distance(ConvertIntVec3ToVector3(TargetDrillingCell),ConvertIntVec3ToVector3(TargetDrillingCell));*/
            fuelRatePerTick = refuelableComp.ConsumptionRatePerTick;
            fuelRatePerHour = fuelRatePerTick * 2500;
            slagChunkEveryNumSteelConsumed = Props.slagChunkEveryNumSteelConsumed;
            //Log.Message($"fuelRatePerHour 1 = {fuelRatePerHour}");
        }//leave as is

        public override void Initialize(CompProperties props)
        {
            base.Initialize(props);
            SetDefaultTargetMineral();
        }//leave as is

        public override void PostExposeData()
        {
            base.PostExposeData();
            Scribe_Values.Look(ref portionProgress, "portionProgress", 0f);
            Scribe_Values.Look(ref portionYieldPct, "portionYieldPct", 0f);

            Scribe_Values.Look(ref lastCell, "lastCell");
            Scribe_Values.Look(ref distanceToCell, "distanceToCell", 0f);
            //Scribe_Values.Look(ref distanceToDig, "distanceToDig", 0);
            Scribe_Values.Look(ref distanceCellsDug, "distanceCellsDug", 0);
            Scribe_Values.Look(ref digProgress, "digProgress", 0f);
            Scribe_Values.Look(ref digOrDrill, "digOrDrill", 0);
            Scribe_Values.Look(ref drillAutoMode, "drillAutoMode", true);
            Scribe_Values.Look(ref steelConsumed, "steelConsumed", 0);
            Scribe_Values.Look(ref isPawnWorking, "isPawnWorking", true);
            Scribe_Values.Look(ref tickCount, "tickCount", 0); 


            Scribe_Defs.Look(ref TargetDrillingDef, "TargetDrillingDef");
            Scribe_Values.Look(ref TargetDrillingCell, "TargetDrillingCell", parent.Position);
            Scribe_Values.Look(ref TargetDrillingCountRemaining, "TargetDrillingCountRemaining");
            Scribe_Defs.Look(ref gizmoTargetResource, "gizmoTargetResource");
            if (Scribe.mode == LoadSaveMode.PostLoadInit && gizmoTargetResource == null)
            {
                SetDefaultTargetMineral();
            }
        }

        private void SetDefaultTargetMineral()
        {
            gizmoTargetResource = ThingDefOf.MineableGold;
        }

        public static Vector3 ConvertIntVec3ToVector3(IntVec3 intVec)//leave as is
        {
            return new Vector3(intVec.x, intVec.y, intVec.z);
        }

        public override void PostDeSpawn(Map map, DestroyMode mode = DestroyMode.Vanish)//leave as is
        {
            portionProgress = 0f;
            portionYieldPct = 0f;
            drillStatus = 4;
            digOrDrill = 0;
            distanceCellsDug = 0;
            lastCell = parent.Position;
            ShutDownEffects();
        }

        public void UpdateDeepResourceDictionary()// Finds location of desired resources
        {

            deepResourceDictionary.Clear();
            DeepResourceGrid deepResourceGrid = parent.Map.deepResourceGrid;

            //Log.Message(parent.Map.info.Size); // returns 250,1,250... scan x 0 to 250, and z 0 to 250

            int mapX = parent.Map.info.Size.x;
            int mapY = 0;
            int mapZ = parent.Map.info.Size.z;

            //Log.Message($"mapX = {mapX}");
            //Log.Message($"mapZ = {mapZ}");


            //Log.Message("GIZMO - Creating Dictonary");
            for (int i = 0; i < mapX; i++)
            {
                for (int j = 0; j < mapZ; j++)
                {
                    IntVec3 temp = new IntVec3(i, mapY, j);
                    if ((deepResourceGrid.ThingDefAt(temp) == gizmoTargetResource.building.mineableThing))
                    {
                        deepResourceDictionary.Add(temp, gizmoTargetResource.building.mineableThing);
                        //Log.Message($"deepResourceGrid.ThingDefAt(temp) = {deepResourceGrid.ThingDefAt(temp)} @ ({i},1,{j})");
                    }
                }
            }
            //Log.Message("GIZMO - Dictonary Complete");
            UpdateInstanceTargets();
            //UpdateDigDistance();
            //Key is IntVec3, Value is ThingDef

        }

        private void UpdateInstanceTargets() //debug gizmo for now, should be called automatically later if the dictionary has values
        {
            //Key is IntVec3, Value is ThingDef
            if (deepResourceDictionary.Count == 0)
            {
                //Log.Message("Dictionary Empty in UpdateInstanceTargets");
                return;
            }

            /*
            if (TargetDrillingDef == null || TargetDrillingCell == IntVec3.Zero)
            {
                Log.Message("Nothing to target");                
                return;
            }*/

            TargetDrillingCell = deepResourceDictionary.First().Key;
            TargetDrillingDef = deepResourceDictionary.First().Value;
            UpdateTargetDrillingCountRemaining();
            distanceToCell = (int)Vector3.Distance(ConvertIntVec3ToVector3(parent.Position), ConvertIntVec3ToVector3(TargetDrillingCell));

            UpdateLastCell();
            //UpdateDigDistance();
            //Log.Message($"TargetDrillingDef = {TargetDrillingDef}\tTargetDrillingCell = {TargetDrillingCell}");
        }

        private void UpdateLastCell(bool done = false)
        {
            if (lastCell == IntVec3.Zero)
            {
                lastCell = parent.Position;
            }
            if (done)
            {
                lastCell = TargetDrillingCell;
            }
        }

        private void RemoveDeepResourceFromDictionary(IntVec3 cellToRemove)
        {
            //Log.Message($"Removing {deepResourceDictionary[cellToRemove]} @ {cellToRemove} from the Dictionary");
            deepResourceDictionary.Remove(cellToRemove);
            distanceCellsDug = 0;
        }

        private void DisplayDeepResourceDictionary()
        {
            foreach (var item in deepResourceDictionary)
            {
                Log.Message($"Key: {item.Key}\t Value: {item.Value}");
            }

            if (deepResourceDictionary.Count == 0)
            {
                Log.Message("Dictionary is Empty");
            }
        }

        private void ShowAllVariables()
        {
            Log.Message($"distanceToCell\t\t= {distanceToCell}");
            Log.Message($"distanceToDig\t\t= {distanceToDig}");
            Log.Message($"distanceCellsDug\t\t= {distanceCellsDug}");
            Log.Message($"lastCell\t\t= {lastCell}");
            Log.Message($"gizmoTargetResource\t\t= {gizmoTargetResource}");
            Log.Message($"TargetDrillingDef\t\t= {TargetDrillingDef}");
            Log.Message($"TargetDrillingCell\t\t= {TargetDrillingCell}");
            Log.Message($"TargetDrillingCountRemaining\t\t= {TargetDrillingCountRemaining}");
            Log.Message($"drillStatus\t\t= {drillStatus}");
            Log.Message($"portionProgress\t\t= {portionProgress}");
            Log.Message($"portionYieldPct\t\t= {portionYieldPct}");
            Log.Message($"digProgress\t\t= {digProgress}");
            Log.Message($"digOrDrill\t\t= {digOrDrill}");
            Log.Message($"drillAutoMode\t\t= {drillAutoMode}");
            Log.Message($"steelConsumed\t\t= {steelConsumed}");
            Log.Message($"isPawnWorking\t\t= {isPawnWorking}");
            Log.Message($"tickCount\t\t= {tickCount}"); 
            Log.Message("----------------------------------------");
            DisplayDeepResourceDictionary();
        }

        private void UpdateTargetDrillingCountRemaining()
        {
            var temp = parent.Map.deepResourceGrid.CountAt(TargetDrillingCell);
            if (temp <= 0)
            {
                TargetDrillingCountRemaining = 0;
            }
            else
            {
                TargetDrillingCountRemaining = temp;
            }
        }

        private void TryPlaceMetalScrap() // tbd - only triggered via gizmo right now
        {
            int randomNumber = Rand.Range(0, 100);
            if(randomNumber >= 0)
            {
                Thing thing = ThingMaker.MakeThing(chunkSlagSteelDef);
                GenPlace.TryPlaceThing(thing, parent.InteractionCell, parent.Map, ThingPlaceMode.Near, null, (IntVec3 p) => p != parent.Position && p != parent.InteractionCell);
                chunkSlagSound.PlayOneShot(thing);
            }
            return;
        }

        private void CheckIfSpawnSteelSlagChunk(int delta = 1)
        {
            steelConsumed += delta * fuelRatePerTick;
            //Log.Message($"steelconsumed = {steelConsumed}\tdelta = {delta}\t fuelRatePerTick = {fuelRatePerTick}");

            if (steelConsumed >= slagChunkEveryNumSteelConsumed)
            {
                TryPlaceMetalScrap();
                steelConsumed = (steelConsumed - slagChunkEveryNumSteelConsumed < 0) ? 0 : steelConsumed - slagChunkEveryNumSteelConsumed;
            }
        }

        public bool CanDrillNow() // this checks if we can even do any drilling

        {

            //Key is IntVec3, Value is ThingDef
            /*
            { 1, "MapDrillStatusActiveManned" },
            { 2, "MapDrillStatusActiveUnmanned" }, // to be implemented
            { 3, "MapDrillStatusActiveStandby" },
            { 4, "MapDrillStatusActiveOffline" },
            { 5, "MapDrillStatusActiveDigging" },
            */
            UpdateInstanceTargets();

            if (!powerComp.PowerOn || !flickComp.SwitchIsOn) // false check
            {
                drillStatus = 4;
                //Log.Message("Error 1");
                ShutDownEffects();
                return false;
            } 

            if (!refuelableComp.HasFuel || deepResourceDictionary.Count == 0) // fuel isn't ready or there isn't anything to mine in the list
            {
                //Log.Message($"refuelableComp.Fuel = {refuelableComp.Fuel}\tdeepResourceDictionary.Count = {deepResourceDictionary.Count}");
                //Log.Message("Error 2");
                ShutDownEffects();
                return false;
            }

            if (deepResourceDictionary.Count > 0 && drillStatus == 3) // there's stuff to mine and I'm on standby
            {
                if (TargetDrillingCountRemaining == 0) {
                    //Log.Message("Error 3.0");
                    RemoveDeepResourceFromDictionary(TargetDrillingCell);
                    //sustainer.End();
                    return false;
                }; // gets a new target if needed when ready to dig/drill


                //Log.Message("Error 3");
            }
                    
            if (distanceToDig == 0) // can I dig or drill now?
            {
                digOrDrill = 1; // distance is 0, DRILL
                drillStatus = 1;
                //Log.Message("@@@@@@@@@@@@@@@@@ DEBUG 1 @@@@@@@@@@@@@@@");
            }
            else
            {
                digOrDrill = 0; // distance is 0, get digging
                drillStatus = 5;
            }

            //Log.Message("Error 5");
                        return true;
        }

        public override void CompTickRare() // testing this..
        {
            //Log.Message("rare tick!");

            Log.Message($"!powerComp.PowerOn = {!powerComp.PowerOn}\t!flickComp.SwitchIsOn = {!flickComp.SwitchIsOn}");
            if (!powerComp.PowerOn || !flickComp.SwitchIsOn)
            {
                ShutDownEffects();
                return;
            }

            isPawnWorking = IsPawnWorkingOnMapDrill();
            if (isPawnWorking)
            {
                if (sustainer != null && !sustainer.Ended)
                {
                    sustainer.End();
                }
                return;
            }

            if (CanDrillNow() & !isPawnWorking) 
            {
                if (sustainer == null || sustainer.Ended)
                {
                    sustainer = Props.soundDefSustainer.TrySpawnSustainer(SoundInfo.InMap(parent));
                }
                sustainer.Maintain();
                this.parent.GetComp<CompRefuelable_MapDrill>().ConsumeFuel(fuelRatePerTick * 250);
                RunDrill(250);
            }
        }

        public override void CompTick()
        {
            tickCount++;
            if (tickCount >= 250)
            {
                CompTickRare();
                tickCount = 0;
                return;
            }
            

            if (!isPawnWorking && powerComp.PowerOn && flickComp.SwitchIsOn)
            {
                //FleckMaker.ThrowDustPuff(this.parent.DrawPos, this.parent.Map, Rand.Range(0.8f, 1.2f));
                if (effecter == null)
                {
                    effecter = Props.effecterDefForAutoMode.SpawnAttached(this.parent, this.parent.Map);
                }
                effecter?.EffectTick(this.parent, this.parent);
            }
            else 
            { ShutDownEffects(); }
        }

        public void ShutDownEffects()
        {
            if (effecter != null) { effecter.Cleanup(); }
            if (sustainer != null) { sustainer.End(); }
        }

        public bool IsPawnWorkingOnMapDrill()
        {
            foreach (Pawn pawn in this.parent.Map.mapPawns.AllPawnsSpawned)
            {
                if (pawn.IsColonist && pawn.jobs != null && pawn.jobs.curJob != null)
                {
                    Job currentJob = pawn.jobs.curJob;
                    if (currentJob.targetA.Thing == this.parent && currentJob.workGiverDef == mapDrillWorkGiverDef)
                    {
                        return true;
                    }
                }
            }
            return false;
        }

        public void RunDrill(int delta = 1, Pawn driller = null) //called by JobDriver_OperateMapDrill
        {
            UpdateTargetDrillingCountRemaining();

            /*
            if (driller == null)
            {
                drillAutoMode = true;
            }
            else
            {
                drillAutoMode = false;
            }*/

            float DrillSpeed;
            float DrillYield;
            float finalDrillSpeed;

            // pawn drill speed 1 at lvl 10 mining, delta = 1 if watching pawn, 15 is not watching... thinking autominer should be delta 60

            if (driller == null)
            {
                DrillSpeed = Props.drillAutoModeSpeed;
                DrillYield = Props.drillAutoModeYield;

            } 
            else
            {
                DrillSpeed = driller.GetStatValue(StatDefOf.DeepDrillingSpeed);
                DrillYield = driller.GetStatValue(StatDefOf.MiningYield);
            }

            finalDrillSpeed = DrillSpeed * (float)delta;
            //Log.Message($"DrillSpeed = {DrillSpeed}\tfinalDrillSpeed = {finalDrillSpeed}\t delta = {delta}\t DrillYield = {DrillYield}");

            var tempBool = (drillStatus == 3 || drillStatus == 5);

            CheckIfSpawnSteelSlagChunk(delta);

            if (digOrDrill == 0 && distanceToDig != 0 && tempBool) // need to dig to next cell
            {
                UpdateLastCell(true);
                drillStatus = 5;
                //Log.Message("@@@@@@@@@@@@@@@@@ DEBUG 2 @@@@@@@@@@@@@@@");
                digProgress += finalDrillSpeed;

                if (digProgress > 10000f)
                {
                    digProgress = 1f;
                    distanceCellsDug ++;
                }
            }

            if (distanceCellsDug == distanceToDig) 
            {
                drillStatus = 1;
                //Log.Message("@@@@@@@@@@@@@@@@@ DEBUG 3 RunDrill");
                digOrDrill = 1;
                digProgress = 1f;
            };

            if (digOrDrill == 1) // already dug to cell, begin the drilling
            {
                UpdateLastCell(true);
                digProgress = 1f;
                portionProgress += finalDrillSpeed;
                portionYieldPct += finalDrillSpeed * DrillYield / 10000f;

                if (portionProgress > 10000f)
                {
                    if (driller == null)
                    {
                        TryProducePortion(portionYieldPct);
                    }
                    else
                    {

                        TryProducePortion(portionYieldPct, driller);
                    }
                    portionProgress = 0f;
                    portionYieldPct = 0f;
                }
            }
        }
        
        private void TryProducePortion(float yieldPct, Pawn driller = null) 
        {
            if (TargetDrillingCountRemaining == 0) 
            {
                RemoveDeepResourceFromDictionary(TargetDrillingCell);
                return;
            }
            int maxAmountInCell = Mathf.Min(TargetDrillingCountRemaining, TargetDrillingDef.deepCountPerPortion);

            parent.Map.deepResourceGrid.SetAt(TargetDrillingCell, TargetDrillingDef, TargetDrillingCountRemaining - maxAmountInCell);
            if (TargetDrillingCountRemaining - maxAmountInCell == 0)
            {
                digOrDrill = 0;
                digProgress = 0f;
            }

            //UpdateTargetDrillingCountRemaining();

            int stackCount = Mathf.Max(1, GenMath.RoundRandom((float)maxAmountInCell * yieldPct));
            Thing thing = ThingMaker.MakeThing(TargetDrillingDef);
            thing.stackCount = stackCount;
            GenPlace.TryPlaceThing(thing, parent.InteractionCell, parent.Map, ThingPlaceMode.Near, null, (IntVec3 p) => p != parent.Position && p != parent.InteractionCell);
            if (driller != null)
            {
                Find.HistoryEventsManager.RecordEvent(new HistoryEvent(HistoryEventDefOf.Mined, driller.Named(HistoryEventArgsNames.Doer)));
            }
            if (TargetDrillingCountRemaining == 0) //if there are no underground node resources at this moment
            {
                //Log.Message($"Removing cell - {TargetDrillingCell} from dictionary - @@@@@@");
                RemoveDeepResourceFromDictionary(TargetDrillingCell);
                return;
            }
        }

        public override IEnumerable<Gizmo> CompGetGizmosExtra()//leave as is
        {
             foreach (Gizmo item in base.CompGetGizmosExtra())
            {
                yield return item;
            }

            ThingDef mineableThing = gizmoTargetResource.building.mineableThing;
            Command_Action command_Action = new Command_Action();
            command_Action.defaultLabel = "CommandSelectMineralToScanFor".Translate() + ": " + mineableThing.LabelCap;
            command_Action.defaultDesc = "CommandSelectMineralToScanForDesc".Translate();
            command_Action.icon = mineableThing.uiIcon;
            command_Action.iconAngle = mineableThing.uiIconAngle;
            command_Action.iconOffset = mineableThing.uiIconOffset;
            command_Action.action = delegate
            {
                List<ThingDef> mineables = ((GenStep_PreciousLump)GenStepDefOf.PreciousLump.genStep).mineables;
                List<FloatMenuOption> list = new List<FloatMenuOption>();
                foreach (ThingDef item3 in mineables)
                {
                    ThingDef localD = item3;
                    FloatMenuOption item = new FloatMenuOption(localD.building.mineableThing.LabelCap, delegate
                    {
                        foreach (object selectedObject in Find.Selector.SelectedObjects)
                        {
                            if (selectedObject is Thing thing)
                            {
                                CompDrill_MapDrill comp = thing.TryGetComp<CompDrill_MapDrill>();
                                if (comp != null)
                                {
                                    comp.gizmoTargetResource = localD;
                                }
                            }
                        }
                    }, MenuOptionPriority.Default, null, null, 29f, (Rect rect) => Widgets.InfoCardButton(rect.x + 5f, rect.y + (rect.height - 24f) / 2f, localD.building.mineableThing));
                    list.Add(item);
                }
                Find.WindowStack.Add(new FloatMenu(list));
            };
            yield return command_Action;


            //WIP TESTING GIZMOS
            Command_Action command_ActionFindGizmo = new Command_Action();
            command_ActionFindGizmo.defaultLabel = "UpdateDeepResourceDictionary";
            command_ActionFindGizmo.icon = GizmoShowMapIcon;
            //command_ActionFindGizmo.iconAngle = mineableThing.uiIconAngle;
            //command_ActionFindGizmo.iconOffset = mineableThing.uiIconOffset;
            command_ActionFindGizmo.action = delegate
            {
                UpdateDeepResourceDictionary();
                SoundDefOf.Designate_Claim.PlayOneShot(new TargetInfo(parent.Position, parent.Map));//Tick_High wasn't bad
            };
            yield return command_ActionFindGizmo;

            /*
            Command_Action command_ActionFindGizmo2 = new Command_Action();
            command_ActionFindGizmo2.defaultLabel = "UpdateInstanceTargets";
            command_ActionFindGizmo2.action = delegate
            {
                UpdateInstanceTargets();
            };
            yield return command_ActionFindGizmo2;
            */




            //WIP TESTING GIZMOS


            if (DebugSettings.ShowDevGizmos)
            {
                Command_Action command_ActionDEV = new Command_Action();
                command_ActionDEV.defaultLabel = "DEV: Produce portion (100% yield)";
                command_ActionDEV.action = delegate
                {
                    TryProducePortion(1f);
                };
                yield return command_ActionDEV;

                Command_Action command_ActionDEV2 = new Command_Action();
                command_ActionDEV2.defaultLabel = "DEV: Attempt to make Scrap";
                command_ActionDEV2.icon = ChunkSlagSteel;
                command_ActionDEV2.action = delegate
                {
                    TryPlaceMetalScrap();
                };
                yield return command_ActionDEV2;

                Command_Action command_ActionFindGizmo4 = new Command_Action();
                command_ActionFindGizmo4.defaultLabel = "SHOW VARIABLES";
                command_ActionFindGizmo4.icon = DebugShowVariablesIcon;
                command_ActionFindGizmo4.action = delegate
                {
                    ShowAllVariables();
                };
                yield return command_ActionFindGizmo4;

                Command_Action command_ActionFindGizmo3 = new Command_Action();
                command_ActionFindGizmo3.defaultLabel = "DisplayDeepResourceDictionary";
                command_ActionFindGizmo3.action = delegate
                {
                    DisplayDeepResourceDictionary();
                };
                yield return command_ActionFindGizmo3;
            }

        }

        public override string CompInspectStringExtra()// this needs to be rewritten
                                                       // conversion to make:
                                                       // targetCell -> TargetDrillingCell
                                                       // countPresent & targetResourceRemaining -> TargetDrillingCountRemaining
                                                       // resDef -> TargetDrillingDef
        /*
            { 1, "MapDrillStatusActiveManned" },
            { 2, "MapDrillStatusActiveUnmanned" }, // to be implemented
            { 3, "MapDrillStatusActiveStandby" },
            { 4, "MapDrillStatusActiveOffline" },
            { 5, "MapDrillStatusActiveDigging" },
        */
        {
            if (parent.Spawned)
            {
                UpdateTargetDrillingCountRemaining();
                //GetNextResource(out var resDef, out var countPresent, out targetCell);

                if (drillStatus == 1 || drillStatus == 5)
                {
                    
                    CompProperties_Refuelable_MapDrill comp = MapDrillDef.GetCompProperties<CompProperties_Refuelable_MapDrill>();
                    string PROPFuelLabel = comp.fuelLabel.Translate();

                    String tempDef;

                    if (TargetDrillingDef == null)
                    {
                        tempDef = "Pending";
                    } else 
                    {
                        tempDef = TargetDrillingDef.LabelCap;
                    }


                    return
                        drillStatusDictionary[drillStatus].Translate() + /*"\tDrillStatus (0/1 dig/drill) = " + digOrDrill + */"\n" +
                        "TargetMapDrillResource".Translate() + tempDef + "\t\t | " + "TargetMapDrillResourceRemaining".Translate() + TargetDrillingCountRemaining + "\n" +
                        "MapDrillProgress".Translate() + ProgressToNextPortionPercent.ToStringPercent("F0") + "\t\t | " + "MapDrillDigProgressString".Translate() + DigProgressToNextPortionPercent.ToStringPercent("F0") + "\n" +
                        "MapDrillDistanceString".Translate() + (int)distanceToCell + "\t | " + "MapDrillDistanceRemainingString".Translate() + (int)(distanceToDig) + "\n" +
                        PROPFuelLabel + "MapDrillSteelConsumptionRateString".Translate() + fuelRatePerHour;

                }
            }
            return null;
        }

        public override void PostDrawExtraSelectionOverlays()
                                                             // this needs to be rewritten. called by JobDriver_OperateMapDrill
                                                             // conversion to make:
                                                             // targetCell -> TargetDrillingCell
                                                             // countPresent & targetResourceRemaining -> TargetDrillingCountRemaining
                                                             // resDef -> TargetDrillingDef
        {

            SimpleColor simpleColor = SimpleColor.Red;
            Vector3 targetPosition = TargetDrillingCell.ToVector3Shifted();
            Vector3 parentPosition = parent.Position.ToVector3Shifted();
            GenDraw.DrawCircleOutline(targetPosition, 1f, simpleColor);
            GenDraw.DrawLineBetween(targetPosition, parentPosition, simpleColor); // to do: harmony patch on GenDraw to make the parent.position in the center of the drill
        }

    }
}
